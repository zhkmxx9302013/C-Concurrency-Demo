# 第三章笔记
## 3.1 Mutex保护共享数据
1. 互斥量通常会与保护的数据放在同一个类中，而不是定义成全局变量。这是面向对象设计的准则：将其放在一个类中，就可让他们联系在一起，也可对类的功能进行封装，并进行数据保护。
2. 在确保成员函数不会传出指针或引用的同时，检查成员函数是否通过指针或引用的方式来调用也是很重要的(尤其是这个操作不在你的控制下时)。函数可能没在互斥量保护的区域内，存储着指针或者引用，这样就很危险。更危险的是：将保护数据作为一个运行时参数。

### 3.1.1 实现一个线程安全的Stack
假设有一个 `stack<vector<int>>` ，vector是一个动态容器，当拷贝一个vetcor，标准库会从堆上分配很多内存来完成这次拷贝。当这个系统处在重度负荷，或有严重的资源限制的情况下，这种内存分配就会失败，所以vector的拷贝构造函数可能会抛出一个 `std::bad_alloc` 异常。当vector中存有大量元素时，这种情况发生的可能性更大。当pop()函数返回“弹出值”时(也就是从栈中将这个值移除)，会有一个潜在的问题：这个值被返回到调用函数的时候，栈才被改变；但当拷贝数据的时候，调用函数抛出一个异常会怎么样？ 如果事情真的发生了，要弹出的数据将会丢失；它的确从栈上移出了，但是拷贝失败了！ `std::stack `的设计人员将这个操作分为两部分：先获取顶部元素(`top()`)，然后从栈中移除(`pop()`)。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。当问题是堆空间不足，应用可能会释放一些内存，然后再进行尝试。不幸的是，这样的分割却制造了本想避免或消除的条件竞争。

#### 解决方案：
1. 传入引用
   ```c++
   std::vector<int> result; 
   some_stack.pop(result);
   ```
   * 优点：在大多数情况下，可以通过临时构造的堆中类型实例接收目标值。避免数据在异常时丢失。 
   * 缺点：需要临时构造出一个堆中类型的实例，用于接收目标值。对于一些类型，这样做是不现实的，因为临时构造一个实例，从时间和资源的角度上来看，都是不划算。对于其他的类型，这样也不总能行得通，因为构造函数需要的一些参数，在代码的这个阶段不一定可用。最后，需要可赋值的存储类型，这是一个重大
限制：即使支持移动构造，甚至是拷贝构造(从而允许返回一个值)，很多用户自定义类型可能都不支持赋值操作。
2. 移动、拷贝构造器禁用异常抛出
    - 使用 `std::is_no_throw_copy_constructible `与`std::is_nothrow_move_constructible` 类型特征，让拷贝或移动构造函数不抛出异常，但是这种方式的局限性太强。很多用户定义类型有可抛出异常的拷贝构造函数，没有移动构造函数；或是，都不抛出异常的构造函数(这种改变会随着C++11中左值引用，越来越为大众所用)。
3. 返回指向Pop值的指针
    使用 `std::shared_ptr` 是个不错的选择；不仅能避免内存泄露(因为当对象中指针销毁时，对象也会被销毁)，而且标准库能够完全控制内存分配方案，也就不需要`new`和`delete`操作。这种优化是很重要的：因为堆栈中的每个对象，都需要用`new`进行独立的内存分配，相较于非线程安全版本，这个方案的开销相当大。
   * 优点：返回一个指向弹出元素的指针，而不是直接返回值。指针的优势是自由拷贝，并且不会产生异常，
   * 缺点：返回一个指针需要对对象的内存分配进行管理，对于简单数据类型(比如：int)，内存管理的开销要远大于直接返回
值。

    **Demo中采用1+3的方式实现**